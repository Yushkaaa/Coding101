//пример №1
let a = 12;
function f() {
    let b = 42;

    console.log(b);
    console.log(a);
}
f();
f();
f(); 
/*переменная b, существует только в приделах функиции, 
каждый раз при вызывании она создается заново*/
/*переменная а глобальная, существует вне функции */
/*можно сказать, что область видимости function f() замкнуто
на  переменная а*/


 //счетчик
let count = 0;

function counter(){
    count++;
    return count;
}

console.log(counter());//1
console.log(counter());//2
console.log(counter());//3

/*обьявили count вне функции, чтоб  она не 
обнулялась каждый раз призапуске функции*/

/*Но что есди надо создасть много счетчиков, не удобно 
каждый раз создавать новую переменную countрешение этой 
проблемы нам как раз таки дает замыкание*/


//пример изпользования замыкания
function Counter(){
    let count = 0;

    return function(){
        count++;

        return count;
    }
}

/*В функции объявляет count, и возвращвет новую функцию.
Эта новая функция, возвращаемая из Counter, она замкнута 
на области видимости родителя, то бишь на область видимости функции Counter */




//Разбор примера
var y = 5;
var x = function(){
    return y;
};
var z = function(t){
    var y = 10;
    return t();
};


// объявляем глобальную переменную "y" = 5
var y = 5; 
// объявляем глобальную переменную содержащую функцию, 
// учитываем что для нее будет "сохранен" контекст, 
// а именно объект вызова и глобальный объект.
var x = function(){
    // возвращаем значение переменной "y". 
    // т.к. локальная переменная "y" отсутствует, 
    // поиск будет произведен в вышестоящем объекте 
    // цепочки областей видимости (в глобальном объекте)
    return y;
};
// объявляем еще одну глобальную переменную содержащую функцию,
// принимающую в качестве аргумента другую функцию
var z = function(t){
    // внутри функции объявляем локальную переменную "y"=10,
    // она перекроет глобальную переменную "y"=5
    var y = 10;
    // возвращаем результат выполнения функции,
    // переданной в качестве аргумента.
    // ВСПОМИНАЕМ, что вместе с функцией хранится и передается 
    // контекст в котором функция была объявлена!
    return t();
};
// вызываем объявленную функцию, 
// передав в качестве аргумента функцию "x" объявленную ранее.
// Не забываем про контекст функции "x"!
z(x);

/*!!!!!!!ОЧЕНЬ ВАЖНО!!!!!!!!
Таким образом, в момент, когда мы попытаемся выполнить функцию x(), 
произойдет следующее — интерпретатор JavaScript попытается найти в 
объекте вызова переменную с именем y, не найдет ее и переключится 
на поиск в глобальном объекте. В глобальном объекте переменная с 
именем y существует, т.к. мы объявили ее прямо перед объявлением функции.*/
 


///Пример
var y = 5;
var x = function(){
    return y;
};
var z = function(t){
    var y = 10;
    return t();
};
y = 15;
console.log(z(x));//вывод равен 15

//пример
var y = 5;
var x = function(){
    return y;
};
var z = function(t){
    y = 10; //это не объявление переменной, это ссылка на глобальную переменную
    return t();
};
console.log(z(x));//вывод равен 10
/* Во второйм примере результат функции 10,потому что внутри функции z() 
мы уже не объявляем локальную переменную y, а ссылаемся на глобальную.  */
